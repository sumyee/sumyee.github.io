import{d as s}from"./app.d8cb38ab.js";const n={},a=s('<h3 id="基于原型链继承" tabindex="-1"><a class="header-anchor" href="#基于原型链继承" aria-hidden="true">#</a> 基于原型链继承</h3><blockquote><p>基本思想就是通过原型继承多个引用类型的<strong>属性</strong>和<strong>方法</strong>。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.property </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">true</span><span style="color:#F8F8F2;">;</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">getSuperValue</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.property;</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.subproperty </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">false</span><span style="color:#F8F8F2;">;</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#88846F;">// 继承 SuperType</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">getSubValue</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.subproperty;</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance.</span><span style="color:#A6E22E;">getSuperValue</span><span style="color:#F8F8F2;">()); </span><span style="color:#88846F;">// true </span></span>\n<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div></div><ul><li><code>SubType</code> 通过创建 <code>SuperType</code> 的实例并将其赋值给自己的原型 <code>SubTtype. prototype</code> 实现了对 <code>SuperType</code> 的继承。</li><li>这个赋值重写了 <code>SubType</code> 最初的原型，将其替换为 <code>SuperType</code> 的实例。</li><li>这意味着 <code>SuperType</code> 实例可以访问的所有属性和方法也会存在于 <code>SubType. prototype</code>。</li></ul><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><blockquote><ol><li><strong>父类方法可以复用</strong></li></ol></blockquote><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><blockquote><ol><li><p><strong>原型中包含的引用值会在所有实例间共享</strong> （父类的所有<code>引用属性</code>会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响）</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {}</span></span>\n<span class="line"><span style="color:#88846F;">// 继承 SuperType</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>\n<span class="line"></span></code></pre></div><p>在这个例子中，<code>SuperType</code> 构造函数定义了一个 <code>colors</code> 属性，其中包含一个数组（引用值）。每 个 <code>SuperType</code> 的实例都会有自己的 <code>colors</code> 属性，包含自己的数组。但是，当 <code>SubType</code> 通过原型继承 <code>SuperType</code> 后，<code>SubType.prototype</code> 变成了 <code>SuperType</code> 的一个实例，因而也获得了自己的 <code>colors</code> 属性。这类似于创建了 <code>SubType.prototype.colors</code> 属性。最终结果是，<code>SubType</code> 的所有实例都会 共享这个 <code>colors</code> 属性。</p></li><li><p><strong>子类型在实例化时不能给父类型的构造函数传参</strong></p></li></ol></blockquote><h3 id="基于构造函数继承" tabindex="-1"><a class="header-anchor" href="#基于构造函数继承" aria-hidden="true">#</a> 基于构造函数继承</h3><blockquote><p>基本思路很简单：在子类构造函数中调用父类构造函数。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 继承 SuperType</span></span>\n<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green&quot; </span></span>\n<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div></div><ul><li>通过使用 <code>call()</code>（或 <code>apply()</code>）方法，<code>SuperType</code> 构造函数在为 <code>SubType</code> 的实例创建的新对象的上下文中执行了。</li><li>这相当于新的 <code>SubType</code> 对象上运行了 <code>SuperType()</code>函数中的所有初始化代码。结果就是每个实例都会有自己的 <code>colors</code> 属性。</li></ul><h4 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点</h4><blockquote><ol><li><p><strong>可以在子类构造函数中向父类构造函数传参</strong></p></li><li><p><strong>父类的引用属性不会被共享</strong></p></li></ol></blockquote><h4 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h4><blockquote><ol><li><strong>必须在构造函数中定义方法</strong></li><li><strong>子类也不能访问父类原型上定义的方法</strong>（即不能访问<code>SuperType.prototype</code>上定义的方法）</li></ol></blockquote><h3 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承" aria-hidden="true">#</a> 组合继承</h3><blockquote><p>基本的思路：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</p><p>（这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。）</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">){</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name);</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">age</span><span style="color:#F8F8F2;">){</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 继承属性</span></span>\n<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">, name); </span><span style="color:#88846F;">// 第二次调用 SuperType()</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#88846F;">// 继承方法</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 第一次调用 SuperType()</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">29</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance1.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;Nicholas&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance1.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 29</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Greg&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">27</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green&quot;</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance2.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;Greg&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">instance2.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 27 </span></span>\n<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div></div><h4 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点</h4><ol><li><strong>融合了原型链继承和构造函数继承的优点</strong></li></ol><h4 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点</h4><ol><li><strong>父类的构造函数被调用了两次</strong>（代码执行（第一次调用 <code>SuperType</code> 构造函数）后 <code>SubType.prototype</code> 上会有两个属性：<code>name</code> 和 <code>colors</code>。它们都是 <code>SuperType</code> 的实例属性，但现在成为了 <code>SubType</code> 的原型属性。在调用 <code>SubType</code> 构造函数时，也会调用 <code>SuperType</code> 构造函数（第二次调用），这一次会在新对象上创建实例属 性 <code>name</code> 和 <code>colors</code>。这两个实例属性会遮蔽原型上同名的属性。）</li></ol><h3 id="原型式继承" tabindex="-1"><a class="header-anchor" href="#原型式继承" aria-hidden="true">#</a> 原型式继承</h3><blockquote><p>创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">o</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 创建临时构造函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">F</span><span style="color:#F8F8F2;">() {}</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 将传入的对象赋值给这个构造函数的原型（F 的实例都将继承 o 上的方法）</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">F</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> o;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 返回实例</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">F</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">} </span></span>\n<span class="line"></span></code></pre></div><p>本质上，<code>object()</code>是对传入的对象执行了一次浅复制。</p><p><u>ECMAScript 5 通过增加 <code>Object.create()</code>方法将原型式继承的概念规范化了。</u></p><p>这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时， <code>Object.create()</code>与这里的 <code>object()</code>方法效果相同。</p><p><code>Object.create()</code>的第二个参数与 <code>Object.defineProperties()</code>的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。如：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> person </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    name: </span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    friends: [</span><span style="color:#E6DB74;">&quot;Shelby&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Court&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Van&quot;</span><span style="color:#F8F8F2;">]</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> anotherPerson </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Object</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">create</span><span style="color:#F8F8F2;">(person, {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    name: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        value: </span><span style="color:#E6DB74;">&quot;Greg&quot;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">});</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(anotherPerson.name); </span><span style="color:#88846F;">// &quot;Greg&quot; </span></span>\n<span class="line"></span></code></pre></div><p><u><strong>原型式继承</strong>非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住， <strong>属性中包含的引用值始终会在相关对象间共享</strong>，跟使用原型模式是一样的。</u></p><h3 id="寄生式继承" tabindex="-1"><a class="header-anchor" href="#寄生式继承" aria-hidden="true">#</a> 寄生式继承</h3><blockquote><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p></blockquote><p>基本的寄生继承模式：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">createAnother</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">original</span><span style="color:#F8F8F2;">){</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> clone </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(original); </span><span style="color:#88846F;">// 通过调用函数创建一个新对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    clone.</span><span style="color:#A6E22E;">sayHi</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() { </span><span style="color:#88846F;">// 以某种方式增强这个对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;hi&quot;</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    };</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> clone; </span><span style="color:#88846F;">// 返回这个对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">} </span></span>\n<span class="line"></span></code></pre></div><p>用法：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> person </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    name: </span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    friends: [</span><span style="color:#E6DB74;">&quot;Shelby&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Court&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Van&quot;</span><span style="color:#F8F8F2;">]</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> anotherPerson </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">createAnother</span><span style="color:#F8F8F2;">(person);</span></span>\n<span class="line"><span style="color:#F8F8F2;">anotherPerson.</span><span style="color:#A6E22E;">sayHi</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;hi&quot; </span></span>\n<span class="line"></span></code></pre></div><h4 id="缺点-3" tabindex="-1"><a class="header-anchor" href="#缺点-3" aria-hidden="true">#</a> 缺点</h4><ol><li><strong>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</strong>。</li></ol><h3 id="寄生式组合继承" tabindex="-1"><a class="header-anchor" href="#寄生式组合继承" aria-hidden="true">#</a> 寄生式组合继承</h3><blockquote><p>基本思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p><p>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p></blockquote><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">inheritPrototype</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">subType</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">superType</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">superType</span><span style="color:#F8F8F2;">.prototype); </span><span style="color:#88846F;">// 创建对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    prototype.constructor </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> subType; </span><span style="color:#88846F;">// 增强对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">subType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> prototype; </span><span style="color:#88846F;">// 赋值对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">} </span></span>\n<span class="line"></span></code></pre></div><ol><li>创建父类原型的一个副本</li><li>给返回的 <code>prototype</code> 对象设置 <code>constructor</code> 属性，解决由于重写原型导致默认 <code>constructor</code> 丢失的问题</li><li>将新创建的对象赋值给子类型的原型</li></ol><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name);</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">age</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">, name); </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6E22E;">inheritPrototype</span><span style="color:#F8F8F2;">(SubType, SuperType);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">}; </span></span>\n<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br></div></div><p>这里只调用了一次 <code>SuperType</code> 构造函数，避免了 <code>SubType.prototype</code> 上不必要也用不到的属性， 因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code>方法正常有效。<u>寄生式组合继承可以算是引用类型继承的最佳模式</u>。</p>',47);n.render=function(s,n){return a};export default n;
