import{r as s,o as n,c as a,a as l,F as p,b as o,d as e}from"./app.d8cb38ab.js";const F={},c={id:"_1-两数之和",tabindex:"-1"},t=l("a",{class:"header-anchor",href:"#_1-两数之和","aria-hidden":"true"},"#",-1),r=o(" 1. 两数之和 "),y={href:"https://leetcode-cn.com/problems/two-sum/",target:"_blank",rel:"noopener noreferrer"},i=e('<blockquote><ul><li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</li><li>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</li><li>你可以按任意顺序返回答案。</li></ul></blockquote><h6 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例：</h6><div class="language-markdown ext-md"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#F8F8F2;">输入：nums = </span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">2,7,11,15</span><span style="color:#F8F8F2;">]</span><span style="color:#F8F8F2;">, target = 9</span></span>\n<span class="line"><span style="color:#F8F8F2;">输出：</span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">0,1</span><span style="color:#F8F8F2;">]</span></span>\n<span class="line"><span style="color:#F8F8F2;">解释：因为 nums</span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">]</span><span style="color:#F8F8F2;"> + nums</span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">]</span><span style="color:#F8F8F2;"> == 9 ，返回 </span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">0,1</span><span style="color:#F8F8F2;">]</span><span style="color:#F8F8F2;"> 。</span></span>\n<span class="line"></span></code></pre></div><h6 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路：</h6><ul><li>初始化一个<code>map = new Map()</code></li><li>从第一个元素开始遍历<code>nums</code></li><li>获取目标值与<code>nums[i]</code>的差值，即<code>k = target - nums[i]</code>，判断差值在<code>map</code>中是否存在 <ul><li>不存在（<code>map.has(k)</code>为<code>false</code>）则将<code>nums[i]</code>加入到<code>nums</code>中（key 为<code>nums[i]</code>，value 为<code>i</code>，方便查找<code>map</code>中是否存在某值，并可通过<code>get</code>方法直接拿到下标）</li><li>存在（<code>map.has(k)</code>）则返回<code>[map.get[k], i]</code>，求解结束</li></ul></li><li>遍历结束，则<code>nums</code>中没有符合条件的两个数，返回<code>[]</code></li></ul><p><strong>时间复杂度： O(n)</strong></p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">twoSum</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">nums</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">target</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> map </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Map</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">for</span><span style="color:#F8F8F2;"> (</span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> i </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">; i </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> nums.length; i</span><span style="color:#F92672;">++</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> k </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> target </span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> nums[i];</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (map.</span><span style="color:#A6E22E;">has</span><span style="color:#F8F8F2;">(k)) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> [map.</span><span style="color:#A6E22E;">get</span><span style="color:#F8F8F2;">(k), i];</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    map.</span><span style="color:#A6E22E;">set</span><span style="color:#F8F8F2;">(nums[i], i);</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> [];</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"></span></code></pre></div>',7),d={id:"_21-合并两个有序链表",tabindex:"-1"},u=l("a",{class:"header-anchor",href:"#_21-合并两个有序链表","aria-hidden":"true"},"#",-1),m=o(" 21. 合并两个有序链表"),h={href:"https://leetcode-cn.com/problems/merge-two-sorted-lists/",target:"_blank",rel:"noopener noreferrer"},E=e('<blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p></blockquote><h6 id="示例-1" tabindex="-1"><a class="header-anchor" href="#示例-1" aria-hidden="true">#</a> 示例 ：</h6><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><div class="language-markdown ext-md"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#F8F8F2;">输入：l1 = </span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1,2,4</span><span style="color:#F8F8F2;">]</span><span style="color:#F8F8F2;">, l2 = </span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1,3,4</span><span style="color:#F8F8F2;">]</span></span>\n<span class="line"><span style="color:#F8F8F2;">输出：</span><span style="color:#F8F8F2;">[</span><span style="color:#AE81FF;">1,1,2,3,4,4</span><span style="color:#F8F8F2;">]</span></span>\n<span class="line"></span></code></pre></div><h6 id="解题思路-1" tabindex="-1"><a class="header-anchor" href="#解题思路-1" aria-hidden="true">#</a> 解题思路：</h6><ul><li>遍历两个链表，按顺序比较，谁小就拼接谁，循环直到其中一个链表遍历完</li></ul><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#88846F;">/**</span></span>\n<span class="line"><span style="color:#88846F;"> * Definition for singly-linked list.</span></span>\n<span class="line"><span style="color:#88846F;"> * function ListNode(val, next) {</span></span>\n<span class="line"><span style="color:#88846F;"> *     this.val = (val===undefined ? 0 : val)</span></span>\n<span class="line"><span style="color:#88846F;"> *     this.next = (next===undefined ? null : next)</span></span>\n<span class="line"><span style="color:#88846F;"> * }</span></span>\n<span class="line"><span style="color:#88846F;"> */</span></span>\n<span class="line"><span style="color:#88846F;">/**</span></span>\n<span class="line"><span style="color:#88846F;"> * </span><span style="color:#66D9EF;font-style:italic;">@param</span><span style="color:#88846F;"> </span><span style="color:#A6E22E;text-decoration:underline;">{ListNode}</span><span style="color:#88846F;"> </span><span style="color:#F8F8F2;">l1</span></span>\n<span class="line"><span style="color:#88846F;"> * </span><span style="color:#66D9EF;font-style:italic;">@param</span><span style="color:#88846F;"> </span><span style="color:#A6E22E;text-decoration:underline;">{ListNode}</span><span style="color:#88846F;"> </span><span style="color:#F8F8F2;">l2</span></span>\n<span class="line"><span style="color:#88846F;"> * </span><span style="color:#66D9EF;font-style:italic;">@return</span><span style="color:#88846F;"> </span><span style="color:#A6E22E;text-decoration:underline;">{ListNode}</span></span>\n<span class="line"><span style="color:#88846F;"> */</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">mergeTwoLists</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">l1</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">l2</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> curr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">ListNode</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#88846F;">// dummy 用于最后返回合并的链表</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> dummy </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> curr;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#88846F;">// 如果两个链表都没有走完，就判断大小添加到新的合并链表</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#88846F;">// 新合并链表的当前指针也要往后移动才能继续添加新的节点</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">while</span><span style="color:#F8F8F2;"> (l1 </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">&amp;&amp;</span><span style="color:#F8F8F2;"> l2 </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (l1.val </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> l2.val) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      curr.next </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l1;</span></span>\n<span class="line"><span style="color:#F8F8F2;">      l1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l1.next;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    } </span><span style="color:#F92672;">else</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      curr.next </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l2;</span></span>\n<span class="line"><span style="color:#F8F8F2;">      l2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l2.next;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    curr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> curr.next;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#88846F;">/**</span></span>\n<span class="line"><span style="color:#88846F;">   * 如果 l1 / l2 没有走完，代表 l1 / l2 后面所有的节点都大于当前合并链表的最大节点，</span></span>\n<span class="line"><span style="color:#88846F;">   * 把 l1 / l2 剩余节点直接添加新链表即可</span></span>\n<span class="line"><span style="color:#88846F;">   */</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (l1 </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    curr.next </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l1;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (l2 </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    curr.next </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> l2;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#88846F;">// dummy.next 才是整个链表</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> dummy.next;</span></span>\n<span class="line"><span style="color:#F8F8F2;">};</span></span>\n<span class="line"></span></code></pre></div>',7);F.render=function(o,e){const F=s("OutboundLink");return n(),a(p,null,[l("h2",c,[t,r,l("a",y,[l(F)])]),i,l("h2",d,[u,m,l("a",h,[l(F)])]),E],64)};export default F;
