<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"><title>继承 | Oops的笔记</title><meta name="description" content="一些前端知识笔记"><meta charset="utf-8"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="modulepreload" href="/assets/app.d8cb38ab.js"><link rel="modulepreload" href="/assets/index.html.48305fde.js"><link rel="modulepreload" href="/assets/index.html.87b3c10e.js">
    <link rel="stylesheet" href="/assets/style.8c3d2604.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="Oops的笔记"><span class="site-name can-hide">Oops的笔记</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端知识体系"><span class="title">前端知识体系</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="前端知识体系"><span class="title">前端知识体系</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/frontEnd/javaScript/" class="nav-link router-link-active" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/frontEnd/css/" class="nav-link" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/frontEnd/bom/" class="nav-link" aria-label="BOM"><!--[--><!--]--> BOM <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="浏览器相关"><span class="title">浏览器相关</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="浏览器相关"><span class="title">浏览器相关</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/browser/principle/" class="nav-link" aria-label="浏览器工作原理与实践"><!--[--><!--]--> 浏览器工作原理与实践 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/algorithm/leetCode/" class="nav-link" aria-label="LeetCode"><!--[--><!--]--> LeetCode <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/algorithm/sort/" class="nav-link" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/algorithm/exercises/" class="nav-link" aria-label="算法练习"><!--[--><!--]--> 算法练习 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><span>webpack</span></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/engineering/webpack/" class="nav-link" aria-label="webpack 概念"><!--[--><!--]--> webpack 概念 <!--[--><!--]--></a></li><li class="dropdown-subitem"><a href="/engineering/webpack/webpack4/" class="nav-link" aria-label="webpack 4"><!--[--><!--]--> webpack 4 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/optimization/performance/" class="nav-link" aria-label="关键渲染路径"><!--[--><!--]--> 关键渲染路径 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="网络"><span class="title">网络</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="网络"><span class="title">网络</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/network/" class="nav-link" aria-label="网络分层模型"><!--[--><!--]--> 网络分层模型 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/network/http" class="nav-link" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/network/tcp-udp" class="nav-link" aria-label="TCP &amp; UDP"><!--[--><!--]--> TCP &amp; UDP <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/other/handCoding/" class="nav-link" aria-label="Hand Coding"><!--[--><!--]--> Hand Coding <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/other/regex/" class="nav-link" aria-label="正则表达式"><!--[--><!--]--> 正则表达式 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/other/git/" class="nav-link" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Interview"><span class="title">Interview</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Interview"><span class="title">Interview</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/interview/browser/" class="nav-link" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端知识体系"><span class="title">前端知识体系</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="前端知识体系"><span class="title">前端知识体系</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/frontEnd/javaScript/" class="nav-link router-link-active" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/frontEnd/css/" class="nav-link" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/frontEnd/bom/" class="nav-link" aria-label="BOM"><!--[--><!--]--> BOM <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="浏览器相关"><span class="title">浏览器相关</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="浏览器相关"><span class="title">浏览器相关</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/browser/principle/" class="nav-link" aria-label="浏览器工作原理与实践"><!--[--><!--]--> 浏览器工作原理与实践 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="数据结构与算法"><span class="title">数据结构与算法</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/algorithm/leetCode/" class="nav-link" aria-label="LeetCode"><!--[--><!--]--> LeetCode <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/algorithm/sort/" class="nav-link" aria-label="排序算法"><!--[--><!--]--> 排序算法 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/algorithm/exercises/" class="nav-link" aria-label="算法练习"><!--[--><!--]--> 算法练习 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="工程化"><span class="title">工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><span>webpack</span></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/engineering/webpack/" class="nav-link" aria-label="webpack 概念"><!--[--><!--]--> webpack 概念 <!--[--><!--]--></a></li><li class="dropdown-subitem"><a href="/engineering/webpack/webpack4/" class="nav-link" aria-label="webpack 4"><!--[--><!--]--> webpack 4 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="性能优化"><span class="title">性能优化</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/optimization/performance/" class="nav-link" aria-label="关键渲染路径"><!--[--><!--]--> 关键渲染路径 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="网络"><span class="title">网络</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="网络"><span class="title">网络</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/network/" class="nav-link" aria-label="网络分层模型"><!--[--><!--]--> 网络分层模型 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/network/http" class="nav-link" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/network/tcp-udp" class="nav-link" aria-label="TCP &amp; UDP"><!--[--><!--]--> TCP &amp; UDP <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="其他"><span class="title">其他</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/other/handCoding/" class="nav-link" aria-label="Hand Coding"><!--[--><!--]--> Hand Coding <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/other/regex/" class="nav-link" aria-label="正则表达式"><!--[--><!--]--> 正则表达式 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/other/git/" class="nav-link" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Interview"><span class="title">Interview</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="Interview"><span class="title">Interview</span><span class="right arrow"></span></button><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/interview/browser/" class="nav-link" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">👉 JavaScript</p><ul class=""><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="继承"><!--[--><!--]--> 继承 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#基于原型链继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="基于原型链继承"><!--[--><!--]--> 基于原型链继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#基于构造函数继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="基于构造函数继承"><!--[--><!--]--> 基于构造函数继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#组合继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="组合继承"><!--[--><!--]--> 组合继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#原型式继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="原型式继承"><!--[--><!--]--> 原型式继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#寄生式继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="寄生式继承"><!--[--><!--]--> 寄生式继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/frontEnd/javaScript/jicheng/#寄生式组合继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="寄生式组合继承"><!--[--><!--]--> 寄生式组合继承 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h3 id="基于原型链继承" tabindex="-1"><a class="header-anchor" href="#基于原型链继承" aria-hidden="true">#</a> 基于原型链继承</h3><blockquote><p>基本思想就是通过原型继承多个引用类型的<strong>属性</strong>和<strong>方法</strong>。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.property </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">true</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">getSuperValue</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.property;</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.subproperty </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">false</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#88846F;">// 继承 SuperType</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">getSubValue</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.subproperty;</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance.</span><span style="color:#A6E22E;">getSuperValue</span><span style="color:#F8F8F2;">()); </span><span style="color:#88846F;">// true </span></span>
<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div></div><ul><li><code>SubType</code> 通过创建 <code>SuperType</code> 的实例并将其赋值给自己的原型 <code>SubTtype. prototype</code> 实现了对 <code>SuperType</code> 的继承。</li><li>这个赋值重写了 <code>SubType</code> 最初的原型，将其替换为 <code>SuperType</code> 的实例。</li><li>这意味着 <code>SuperType</code> 实例可以访问的所有属性和方法也会存在于 <code>SubType. prototype</code>。</li></ul><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><blockquote><ol><li><strong>父类方法可以复用</strong></li></ol></blockquote><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><blockquote><ol><li><p><strong>原型中包含的引用值会在所有实例间共享</strong> （父类的所有<code>引用属性</code>会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响）</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {}</span></span>
<span class="line"><span style="color:#88846F;">// 继承 SuperType</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>
<span class="line"></span></code></pre></div><p>在这个例子中，<code>SuperType</code> 构造函数定义了一个 <code>colors</code> 属性，其中包含一个数组（引用值）。每 个 <code>SuperType</code> 的实例都会有自己的 <code>colors</code> 属性，包含自己的数组。但是，当 <code>SubType</code> 通过原型继承 <code>SuperType</code> 后，<code>SubType.prototype</code> 变成了 <code>SuperType</code> 的一个实例，因而也获得了自己的 <code>colors</code> 属性。这类似于创建了 <code>SubType.prototype.colors</code> 属性。最终结果是，<code>SubType</code> 的所有实例都会 共享这个 <code>colors</code> 属性。</p></li><li><p><strong>子类型在实例化时不能给父类型的构造函数传参</strong></p></li></ol></blockquote><h3 id="基于构造函数继承" tabindex="-1"><a class="header-anchor" href="#基于构造函数继承" aria-hidden="true">#</a> 基于构造函数继承</h3><blockquote><p>基本思路很简单：在子类构造函数中调用父类构造函数。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 继承 SuperType</span></span>
<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green&quot; </span></span>
<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br></div></div><ul><li>通过使用 <code>call()</code>（或 <code>apply()</code>）方法，<code>SuperType</code> 构造函数在为 <code>SubType</code> 的实例创建的新对象的上下文中执行了。</li><li>这相当于新的 <code>SubType</code> 对象上运行了 <code>SuperType()</code>函数中的所有初始化代码。结果就是每个实例都会有自己的 <code>colors</code> 属性。</li></ul><h4 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点</h4><blockquote><ol><li><p><strong>可以在子类构造函数中向父类构造函数传参</strong></p></li><li><p><strong>父类的引用属性不会被共享</strong></p></li></ol></blockquote><h4 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h4><blockquote><ol><li><strong>必须在构造函数中定义方法</strong></li><li><strong>子类也不能访问父类原型上定义的方法</strong>（即不能访问<code>SuperType.prototype</code>上定义的方法）</li></ol></blockquote><h3 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承" aria-hidden="true">#</a> 组合继承</h3><blockquote><p>基本的思路：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。</p><p>（这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。）</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">){</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> name;</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name);</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">age</span><span style="color:#F8F8F2;">){</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 继承属性</span></span>
<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">, name); </span><span style="color:#88846F;">// 第二次调用 SuperType()</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> age;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#88846F;">// 继承方法</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 第一次调用 SuperType()</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age);</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">29</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">instance1.colors.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;black&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance1.colors); </span><span style="color:#88846F;">// &quot;red,blue,green,black&quot;</span></span>
<span class="line"><span style="color:#F8F8F2;">instance1.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;Nicholas&quot;;</span></span>
<span class="line"><span style="color:#F8F8F2;">instance1.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 29</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> instance2 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Greg&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">27</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(instance2.colors); </span><span style="color:#88846F;">// &quot;red,blue,green&quot;</span></span>
<span class="line"><span style="color:#F8F8F2;">instance2.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;Greg&quot;;</span></span>
<span class="line"><span style="color:#F8F8F2;">instance2.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// 27 </span></span>
<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div></div><h4 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点</h4><ol><li><strong>融合了原型链继承和构造函数继承的优点</strong></li></ol><h4 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点</h4><ol><li><strong>父类的构造函数被调用了两次</strong>（代码执行（第一次调用 <code>SuperType</code> 构造函数）后 <code>SubType.prototype</code> 上会有两个属性：<code>name</code> 和 <code>colors</code>。它们都是 <code>SuperType</code> 的实例属性，但现在成为了 <code>SubType</code> 的原型属性。在调用 <code>SubType</code> 构造函数时，也会调用 <code>SuperType</code> 构造函数（第二次调用），这一次会在新对象上创建实例属 性 <code>name</code> 和 <code>colors</code>。这两个实例属性会遮蔽原型上同名的属性。）</li></ol><h3 id="原型式继承" tabindex="-1"><a class="header-anchor" href="#原型式继承" aria-hidden="true">#</a> 原型式继承</h3><blockquote><p>创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">o</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 创建临时构造函数</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">F</span><span style="color:#F8F8F2;">() {}</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 将传入的对象赋值给这个构造函数的原型（F 的实例都将继承 o 上的方法）</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">F</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> o;</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#88846F;">// 返回实例</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">F</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">} </span></span>
<span class="line"></span></code></pre></div><p>本质上，<code>object()</code>是对传入的对象执行了一次浅复制。</p><p><u>ECMAScript 5 通过增加 <code>Object.create()</code>方法将原型式继承的概念规范化了。</u></p><p>这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时， <code>Object.create()</code>与这里的 <code>object()</code>方法效果相同。</p><p><code>Object.create()</code>的第二个参数与 <code>Object.defineProperties()</code>的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。如：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> person </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">    name: </span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">,</span></span>
<span class="line"><span style="color:#F8F8F2;">    friends: [</span><span style="color:#E6DB74;">&quot;Shelby&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Court&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Van&quot;</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> anotherPerson </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Object</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">create</span><span style="color:#F8F8F2;">(person, {</span></span>
<span class="line"><span style="color:#F8F8F2;">    name: {</span></span>
<span class="line"><span style="color:#F8F8F2;">        value: </span><span style="color:#E6DB74;">&quot;Greg&quot;</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#F8F8F2;">});</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(anotherPerson.name); </span><span style="color:#88846F;">// &quot;Greg&quot; </span></span>
<span class="line"></span></code></pre></div><p><u><strong>原型式继承</strong>非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住， <strong>属性中包含的引用值始终会在相关对象间共享</strong>，跟使用原型模式是一样的。</u></p><h3 id="寄生式继承" tabindex="-1"><a class="header-anchor" href="#寄生式继承" aria-hidden="true">#</a> 寄生式继承</h3><blockquote><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p></blockquote><p>基本的寄生继承模式：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">createAnother</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">original</span><span style="color:#F8F8F2;">){</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> clone </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(original); </span><span style="color:#88846F;">// 通过调用函数创建一个新对象</span></span>
<span class="line"><span style="color:#F8F8F2;">    clone.</span><span style="color:#A6E22E;">sayHi</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() { </span><span style="color:#88846F;">// 以某种方式增强这个对象</span></span>
<span class="line"><span style="color:#F8F8F2;">        console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;hi&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">    };</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> clone; </span><span style="color:#88846F;">// 返回这个对象</span></span>
<span class="line"><span style="color:#F8F8F2;">} </span></span>
<span class="line"></span></code></pre></div><p>用法：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> person </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">    name: </span><span style="color:#E6DB74;">&quot;Nicholas&quot;</span><span style="color:#F8F8F2;">,</span></span>
<span class="line"><span style="color:#F8F8F2;">    friends: [</span><span style="color:#E6DB74;">&quot;Shelby&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Court&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;Van&quot;</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> anotherPerson </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">createAnother</span><span style="color:#F8F8F2;">(person);</span></span>
<span class="line"><span style="color:#F8F8F2;">anotherPerson.</span><span style="color:#A6E22E;">sayHi</span><span style="color:#F8F8F2;">(); </span><span style="color:#88846F;">// &quot;hi&quot; </span></span>
<span class="line"></span></code></pre></div><h4 id="缺点-3" tabindex="-1"><a class="header-anchor" href="#缺点-3" aria-hidden="true">#</a> 缺点</h4><ol><li><strong>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</strong>。</li></ol><h3 id="寄生式组合继承" tabindex="-1"><a class="header-anchor" href="#寄生式组合继承" aria-hidden="true">#</a> 寄生式组合继承</h3><blockquote><p>基本思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p><p>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p></blockquote><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">inheritPrototype</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">subType</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">superType</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">object</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">superType</span><span style="color:#F8F8F2;">.prototype); </span><span style="color:#88846F;">// 创建对象</span></span>
<span class="line"><span style="color:#F8F8F2;">    prototype.constructor </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> subType; </span><span style="color:#88846F;">// 增强对象</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#66D9EF;font-style:italic;">subType</span><span style="color:#F8F8F2;">.prototype </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> prototype; </span><span style="color:#88846F;">// 赋值对象</span></span>
<span class="line"><span style="color:#F8F8F2;">} </span></span>
<span class="line"></span></code></pre></div><ol><li>创建父类原型的一个副本</li><li>给返回的 <code>prototype</code> 对象设置 <code>constructor</code> 属性，解决由于重写原型导致默认 <code>constructor</code> 丢失的问题</li><li>将新创建的对象赋值给子类型的原型</li></ol><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#272822;"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SuperType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> name;</span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.colors </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&quot;red&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;blue&quot;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&quot;green&quot;</span><span style="color:#F8F8F2;">];</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SuperType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayName</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.name);</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">SubType</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">name</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">age</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">    SuperType.</span><span style="color:#A6E22E;">call</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">, name); </span></span>
<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> age;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6E22E;">inheritPrototype</span><span style="color:#F8F8F2;">(SubType, SuperType);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">SubType</span><span style="color:#F8F8F2;">.prototype.</span><span style="color:#A6E22E;">sayAge</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.age);</span></span>
<span class="line"><span style="color:#F8F8F2;">}; </span></span>
<span class="line"></span></code></pre><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlight-line"> </div><br><br><br><br></div></div><p>这里只调用了一次 <code>SuperType</code> 构造函数，避免了 <code>SubType.prototype</code> 上不必要也用不到的属性， 因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code>方法正常有效。<u>寄生式组合继承可以算是引用类型继承的最佳模式</u>。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><span class="meta-item-info">2021/8/27 下午6:05:33</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 857901398@qq.com">Oops</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main></div><!----><!--]--></div>
    <script type="module" src="/assets/app.d8cb38ab.js" defer></script>
  </body>
</html>
